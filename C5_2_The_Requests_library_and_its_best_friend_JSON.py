# C5.2. Библиотека Requests и её лучший друг JSON

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

# На момент изучения этого материала, вы уже должны знать, что такое 
# библиотеки в Python, как их установить и использовать в ваших проектах, 
# а также вы умеете пользоваться браузером. :) Это всё, что нам понадобится 
# для изучения нового материала в данном юните.

# Но перед тем, как говорить о библиотеке Requests, давайте немного 
# поработаем с браузером.

# В данном юните представлен как пример браузер Firefox. 
# При открытии веб-страницы вы получаете HTML-код этой самой 
# страницы и такие дополнительные вещи, как стили и скрипты 
# в виде отдельных файлов и инструкций о том, как их надо соединить 
# вместе, чтобы получить полноценную картинку и функционал. 
# О стилях и скриптах мы будем говорить подробнее на нашем курсе, когда коснемся фронт-энд разработки. Сейчас же остановимся только на HTML.

# HTML — это язык гипертекстовой разметки.

# Грубо говоря, это скелет самой страницы без стилей, анимаций, 
# рекламы и т. д. Страничка на чистом HTML выглядит примерно 
# следующим образом:

# Страница поисковых запросов в Google без стилей.
# Теперь давайте перейдём в браузер. Если мы нажмём клавишу F12,
# находясь на каком-либо сайте, то внизу (или справа) откроется 
# консоль разработчика.

# Давайте посмотрим, что у нас здесь есть:

# Для того чтобы увидеть сам HTML-код, необходимо перейти 
# во вкладку «Инспектор».

# Именно в этот обыкновенный текст подстраиваются все стили и анимации, 
# и в результате мы получаем то, что мы видим в браузере. 
# Но что если мы не хотим видеть все эти картинки через браузер и 
# постоянно заходить в консоль? Возможно ли забирать со страницы 
# лишь самую главную информацию, не ища её через браузер? Конечно же, да!

# Для этого и существуют специальные Python-библиотеки, одна из 
# которых называется Requests. Она позволяет отправлять запросы 
# на сервера (сайты, для простоты на данный момент) и получать от 
# них ответ в виде, например, кода на HTML.

# Давайте сначала попробуем получить данные с одного интересного API, 
# который генерирует случайные тексты.

# API (Application programming interface) — это набор публичных свойств 
# и методов для взаимодействия с другими программами, которые могут быть 
# написаны даже на другом языке программирования. API можно 
# определить как: «Ко мне можно обращаться так и так, я обязуюсь 
# делать то и это».
# Это делается очень просто — переходим по ссылке через ваш браузер. :)

# В итоге мы увидим примерно следующую картину:

# Нам пришло в ответ нечто, не похожее на веб-страницу, с тремя 
# случайными текстами.

# Давайте теперь попробуем прочитать эти же тексты, но не через браузер, 
# а через наш Python-скрипт с помощью библиотеки Requests. 
# Для этого отправим GET-запрос:

# import requests
#
# r = requests.get('https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')  # делаем запрос на сервер по переданному адресу
# print(r.content)

# В результате работы данного кода в консоль выведется HTML-код 
# сгенерированного текста, т. к. запрос на получение странички через 
# браузер на самом деле эквивалентен вызову функции .get() (и то, и то 
# отправляет GET-HTTP-запрос, о котором мы будем говорить более 
# подробно чуть позже на нашем курсе).

# Ничего не напоминает? Да-да. Это всё тот же HTML-код страницы, 
# который мы видели через консоль, только полученный текстом через 
# Python-скрипт. А знаете к чему это ведёт? Это должно подталкивать 
# нас на мысль, что возможно собирать просто огромные данные с тех 
# же самых страниц, не заходя на них и оставив скрипт работать 
# в фоновом режиме. Именно для этого и нужна библиотека Requests.

# Кстати, такие программы, которые забирают и сохраняют главную 
# информацию с каких-либо сайтов, называются парсерами, их мы будем 
# писать в следующем юните.

# Как вы заметили, чтобы получить содержание ответа надо обратится 
# к полю content объекта response, который возвращается, когда приходит 
# ответ от сервера через библиотеку Requests. У этого объекта, на самом деле, 
# есть много полей, например, status_code, который говорит нам о том, 
# какой вообще ответ пришёл. Давайте поменяем наш код и посмотрим, 
# что программа выведет теперь.

# import requests
#
# r = requests.get('https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')
# print(r.status_code)  # узнаем статус полученного ответа

# Теперь при его выполнении нам в консоли должно было напечататься 200. 
# Это означает, что ответ от сервера поступил нормальный, и мы можем 
# его обрабатывать.

# Есть несколько категорий ответов, например:

#  200, 201, 202 и т. д. — ответы, которые говорят, что с запросом всё хорошо, 
#                                           и ответ приходит правильный, т. е. его можно 
#                                           обрабатывать и как-либо взаимодействовать с ним. 
#                                           На самом деле почти все серверы всегда в ответ шлют 
#                                           именно ответ 200, а не какой-либо другой из этой 
#                                           же категории.

# 300, 301 и т. д. — ответы, которые говорят, что вы будете перенаправлены на
#                                 другой ресурс (не обязательно на этом же сервере).

# 400, 401 и т. д. — ответы, которые говорят, что что-то неправильно с 
#                                 запросом. Запрашивается либо несуществующая страница 
#                                 (всем известная 404 ошибка), либо же недостаточно прав 
#                                 для просмотра страницы (403) и т. д.

# 501, 502 и т. д. — ответы, которые говорят, что с запросом всё хорошо, 
#                                 но вот на сервере что-то сломалось, и поэтому нормальный 
#                                 ответ прийти не может.

# Более подробно со всеми типами ответов можно ознакомиться здесь.

# Информацию с сайта мы можем получать не только в виде HTML, 
# но и в формате JSON.

# JSON переводится как JavaScriptObjectNotation.

# Это определённый тип ответов от сервера, который уже содержит только 
# нужную нам информацию, без всяких HTML-кодов. По сути своей 
# JSON очень похож на структуры данных в Python (словари и списки), но, 
# на самом деле, его изначальной целью было сохранять состояние объектов 
# языка JavaScript (как нетрудно было догадаться из названия). 
# Давайте посмотрим на JSON-ответ, присланный нам с того же 
# самого ресурса. Попробуем с помощью библиотеки Requests обратиться 
# по адресу.

# import requests
#
# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')  # попробуем поймать json-ответ
# print(r.content)

# В результате в консоли мы должны будем увидеть что-то подобное:

# Если приглядеться, то здесь можно увидеть нечто похожее на список 
# в Python. Однако, чтобы использовать полученный ответ как 
# Python-объект, надо воспользоваться дополнительной библиотекой, 
# которая упрощает работу с JSON-ответами и может легко переконвертировать 
# ответ от сервера в Python-объекты, с которыми удобно работать. 
# Давайте поменяем наш код и превратим данный текст в список, на который 
# он так сильно похож.

# import requests
# import json  # импортируем необходимую библиотеку
#
# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
# texts = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
# print(type(texts))  # проверяем тип сконвертированных данных
#
# for text in texts:  # выводим полученный текст. Но для того чтобы он влез в консоль, оставим только первые 50 символов.
#     print(text[:50], '\n')

# После запуска скрипта увидим следующее:

# Теперь мы сделали ответ от сервера списком — структурой данных Python, 
# с которой гораздо приятнее работать, чем просто с байтами.

# Давайте посмотрим теперь на ещё один тип возвращаемых значений. 
# Он тоже будет JSON, но в данном случае он скорее будет похож на словарь.

# import requests
# import json
#
# r = requests.get('https://api.github.com')
#
# print(r.content)

# В консоли мы увидим структуру, похожую на словарь:

# Дело в том, что на самом деле это не совсем словарь. 
# JavaScriptObjectNotation (он же JSON) есть ничто иное, 
# как правило записи JS-объектов в файл, чтобы сохранять их состояния 
# и затем загружать обратно в программу. В модуле JSON, а конкретно 
# в функции loads, за нас уже заранее обо всём позаботились. 
# В зависимости от вида полученного ответа от сервера JSON-функция 
# сама будет обрабатывать его и возвращать нужный нам объект 
# (список или словарь). Подробнее о самой нотации можно почитать вот здесь.

# Но хватит лирики. Давайте всё же теперь сделаем его настоящим словарём.

# import requests
# import json
#
# r = requests.get('https://api.github.com')
#
# d = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
#
# print(type(d))
# print(d['following_url'])  # обращаемся к полученному объекту как к словарю и попробуем напечатать одно из его значений

# Результатом работы программы будет:

# Таким образом мы можем удобно превращать данные полученные из 
# ответа JSON в объекты структур данных Python с помощью библиотеки 
# JSON и удобно работать с ними. В следующем юните разберём более 
# подробно получение данных из больших HTML с помощью специальных 
# библиотек для парсинга.

# Как вы могли заметить, здесь мы использовали только GET-запросы 
# (применяли функцию .get() из библиотеки requests). Однако одним 
# из наиболее распространённых запросов помимо GET является 
# POST-запрос. Если же GET используется как правило для получения 
# данных (например, JSON-ответ или HTML-код для браузера, как мы уже 
# увидели), то при помощи POST-запросов отправляются данные для 
# обработки на сервер. Например, чаще всего вместе с POST-запросом 
# используются параметры (data) для записи каких-либо новых данных 
# в базу данных.

# Давайте попробуем отправить POST-запрос:

# import requests
#
# r = requests.post('https://httpbin.org/post', data = {'key':'value'})  # отправляем пост-запрос
# print(r.content)  # содержимое ответа и его обработка происходит так же, как и с ГЕТ-запросами, разницы никакой нету

# Это простенькое API копирует наш запрос и выводит о нём главную 
# информацию. Давайте посмотрим на вывод в консоль:

# Здесь мы видим, что запрос отправлен с помощью Python-requests и нашу 
# операционную систему ("User-Agent": "Python-requests/2.7.0 CPython/3.6.6 
# Windows/10"),  а также, приглядевшись, мы можем увидеть и наши 
# параметры (строчка: "form": {\n "key": "value"\n }). Обратите внимание, 
# что здесь тип отправляемых нами данных указан как FORM, но многие API, 
# однако, требуют тип JSON в качестве отправляемых данных.

# Давайте посмотрим, как с помощью уже знакомой нам библиотеки 
# отправить данные в нужном нам формате:

# import requests
# import json
#
# data = {'key': 'value'}
#
# r = requests.post('https://httpbin.org/post', json=json.dumps(data))  # отправляем пост-запрос, но только в этот раз тип передаваемых данных будет JSON
# print(r.content)

# Проверяем консоль:

# Здесь нас интересует строчка: "JSON": "{\\"key\\": \\"value\\"}". 
# Из неё мы можем понять, что тип отправленных нами данных 
# был именно JSON. Поле FORM же у нас теперь пустое, что означает, 
# что напрямую никаких данных мы не передавали.

# Таким образом отправляются POST-запросы через библиотеку Requests. 
# Есть ещё другие типы запросов, такие как OPTIONS, PUT, DELETE и т. д. 
# Они используются в основном в так называемых RESTful-сервисах. 
# О них мы будем говорить подробнее дальше на нашем курсе, 
# когда сами будем писать такого рода сервис. В общем-то алгоритм действия 
# с PUT, DELETE и т.д. такой же, как и с другими двумя методами (GET и POST),
# меняется только название вызываемой функции. Обработка и отправка 
# происходит также, как и с уже изученными нами методами.

# Таким образом, мы научились отправлять GET- и POST-запросы с помощью 
# библиотеки Requests в Python. Как правило, разработчики используемого 
# вами API будут указывать, каким методам и типом данных нужно отправлять 
# запросы к их серверу и будут предоставлять примеры ответов (если это 
# конечно хорошее API), что позволит вам легко разобраться с их сервисом.

# Изучив документацию библиотеки Requests, ответьте на вопросы.

# 5.2.1

# Выберите верные утверждения:

#  *  Библиотека Requests используется только для получения HTML-кода 
#      страницы

#  *  Библиотека Requests может отправлять HTTP-запросы методами GET 
#     и POST +++

#  *  Библиотека Requests может принимать ответы любого характера 
#     (HTML-код или JSON-ответ) +++

#  *  JSON-ответ от сервера может быть интерпретирован только как
#      словарь

#  *  JSON можно конвертировать в структуры данных из Python +++

# 5.2.2

# Функция из библиотеки JSON, которая конвертирует байты в Python-объект 
# (например, список или словарь), называется

#  *  load

#  *  loads +++

#  *  dump

#  *  dumps


# 5.2.3

# Напишите программу, которая отправляет запрос на генерацию случайных 
# текстов (используйте этот сервис). Выведите первый из сгенерированных 
# текстов.

# Решение:

# import requests
# import json
#
# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
#
# r = json.loads(r.content)
#
# print(r[0])



